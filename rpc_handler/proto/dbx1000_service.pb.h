// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dbx1000_service.proto

#ifndef PROTOBUF_INCLUDED_dbx1000_5fservice_2eproto
#define PROTOBUF_INCLUDED_dbx1000_5fservice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_dbx1000_5fservice_2eproto 

namespace protobuf_dbx1000_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_dbx1000_5fservice_2eproto
namespace dbx1000 {
class LockDowngradeReply;
class LockDowngradeReplyDefaultTypeInternal;
extern LockDowngradeReplyDefaultTypeInternal _LockDowngradeReply_default_instance_;
class LockDowngradeRequest;
class LockDowngradeRequestDefaultTypeInternal;
extern LockDowngradeRequestDefaultTypeInternal _LockDowngradeRequest_default_instance_;
class LockGetReply;
class LockGetReplyDefaultTypeInternal;
extern LockGetReplyDefaultTypeInternal _LockGetReply_default_instance_;
class LockGetRequest;
class LockGetRequestDefaultTypeInternal;
extern LockGetRequestDefaultTypeInternal _LockGetRequest_default_instance_;
class LockInvalidReply;
class LockInvalidReplyDefaultTypeInternal;
extern LockInvalidReplyDefaultTypeInternal _LockInvalidReply_default_instance_;
class LockInvalidRequest;
class LockInvalidRequestDefaultTypeInternal;
extern LockInvalidRequestDefaultTypeInternal _LockInvalidRequest_default_instance_;
}  // namespace dbx1000
namespace google {
namespace protobuf {
template<> ::dbx1000::LockDowngradeReply* Arena::CreateMaybeMessage<::dbx1000::LockDowngradeReply>(Arena*);
template<> ::dbx1000::LockDowngradeRequest* Arena::CreateMaybeMessage<::dbx1000::LockDowngradeRequest>(Arena*);
template<> ::dbx1000::LockGetReply* Arena::CreateMaybeMessage<::dbx1000::LockGetReply>(Arena*);
template<> ::dbx1000::LockGetRequest* Arena::CreateMaybeMessage<::dbx1000::LockGetRequest>(Arena*);
template<> ::dbx1000::LockInvalidReply* Arena::CreateMaybeMessage<::dbx1000::LockInvalidReply>(Arena*);
template<> ::dbx1000::LockInvalidRequest* Arena::CreateMaybeMessage<::dbx1000::LockInvalidRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace dbx1000 {

enum RpcLockMode {
  O = 0,
  S = 1,
  P = 2,
  X = 3,
  RpcLockMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RpcLockMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RpcLockMode_IsValid(int value);
const RpcLockMode RpcLockMode_MIN = O;
const RpcLockMode RpcLockMode_MAX = X;
const int RpcLockMode_ARRAYSIZE = RpcLockMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RpcLockMode_descriptor();
inline const ::std::string& RpcLockMode_Name(RpcLockMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RpcLockMode_descriptor(), value);
}
inline bool RpcLockMode_Parse(
    const ::std::string& name, RpcLockMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RpcLockMode>(
    RpcLockMode_descriptor(), name, value);
}
// ===================================================================

class LockGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockGetRequest) */ {
 public:
  LockGetRequest();
  virtual ~LockGetRequest();

  LockGetRequest(const LockGetRequest& from);

  inline LockGetRequest& operator=(const LockGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockGetRequest(LockGetRequest&& from) noexcept
    : LockGetRequest() {
    *this = ::std::move(from);
  }

  inline LockGetRequest& operator=(LockGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockGetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockGetRequest* internal_default_instance() {
    return reinterpret_cast<const LockGetRequest*>(
               &_LockGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LockGetRequest* other);
  friend void swap(LockGetRequest& a, LockGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockGetRequest* New() const final {
    return CreateMaybeMessage<LockGetRequest>(NULL);
  }

  LockGetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockGetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockGetRequest& from);
  void MergeFrom(const LockGetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 page_id = 2;
  void clear_page_id();
  static const int kPageIdFieldNumber = 2;
  ::google::protobuf::uint64 page_id() const;
  void set_page_id(::google::protobuf::uint64 value);

  // int32 instance_id = 1;
  void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  ::google::protobuf::int32 instance_id() const;
  void set_instance_id(::google::protobuf::int32 value);

  // .dbx1000.RpcLockMode mode = 3;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::dbx1000::RpcLockMode mode() const;
  void set_mode(::dbx1000::RpcLockMode value);

  // @@protoc_insertion_point(class_scope:dbx1000.LockGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 page_id_;
  ::google::protobuf::int32 instance_id_;
  int mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbx1000_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockGetReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockGetReply) */ {
 public:
  LockGetReply();
  virtual ~LockGetReply();

  LockGetReply(const LockGetReply& from);

  inline LockGetReply& operator=(const LockGetReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockGetReply(LockGetReply&& from) noexcept
    : LockGetReply() {
    *this = ::std::move(from);
  }

  inline LockGetReply& operator=(LockGetReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockGetReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockGetReply* internal_default_instance() {
    return reinterpret_cast<const LockGetReply*>(
               &_LockGetReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LockGetReply* other);
  friend void swap(LockGetReply& a, LockGetReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockGetReply* New() const final {
    return CreateMaybeMessage<LockGetReply>(NULL);
  }

  LockGetReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockGetReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockGetReply& from);
  void MergeFrom(const LockGetReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockGetReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes page_buf = 2;
  void clear_page_buf();
  static const int kPageBufFieldNumber = 2;
  const ::std::string& page_buf() const;
  void set_page_buf(const ::std::string& value);
  #if LANG_CXX11
  void set_page_buf(::std::string&& value);
  #endif
  void set_page_buf(const char* value);
  void set_page_buf(const void* value, size_t size);
  ::std::string* mutable_page_buf();
  ::std::string* release_page_buf();
  void set_allocated_page_buf(::std::string* page_buf);

  // bool rc = 1;
  void clear_rc();
  static const int kRcFieldNumber = 1;
  bool rc() const;
  void set_rc(bool value);

  // @@protoc_insertion_point(class_scope:dbx1000.LockGetReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr page_buf_;
  bool rc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbx1000_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockDowngradeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockDowngradeRequest) */ {
 public:
  LockDowngradeRequest();
  virtual ~LockDowngradeRequest();

  LockDowngradeRequest(const LockDowngradeRequest& from);

  inline LockDowngradeRequest& operator=(const LockDowngradeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockDowngradeRequest(LockDowngradeRequest&& from) noexcept
    : LockDowngradeRequest() {
    *this = ::std::move(from);
  }

  inline LockDowngradeRequest& operator=(LockDowngradeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockDowngradeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockDowngradeRequest* internal_default_instance() {
    return reinterpret_cast<const LockDowngradeRequest*>(
               &_LockDowngradeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LockDowngradeRequest* other);
  friend void swap(LockDowngradeRequest& a, LockDowngradeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockDowngradeRequest* New() const final {
    return CreateMaybeMessage<LockDowngradeRequest>(NULL);
  }

  LockDowngradeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockDowngradeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockDowngradeRequest& from);
  void MergeFrom(const LockDowngradeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockDowngradeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 page_id = 1;
  void clear_page_id();
  static const int kPageIdFieldNumber = 1;
  ::google::protobuf::uint64 page_id() const;
  void set_page_id(::google::protobuf::uint64 value);

  // .dbx1000.RpcLockMode from = 2;
  void clear_from();
  static const int kFromFieldNumber = 2;
  ::dbx1000::RpcLockMode from() const;
  void set_from(::dbx1000::RpcLockMode value);

  // .dbx1000.RpcLockMode to = 3;
  void clear_to();
  static const int kToFieldNumber = 3;
  ::dbx1000::RpcLockMode to() const;
  void set_to(::dbx1000::RpcLockMode value);

  // @@protoc_insertion_point(class_scope:dbx1000.LockDowngradeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 page_id_;
  int from_;
  int to_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbx1000_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockDowngradeReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockDowngradeReply) */ {
 public:
  LockDowngradeReply();
  virtual ~LockDowngradeReply();

  LockDowngradeReply(const LockDowngradeReply& from);

  inline LockDowngradeReply& operator=(const LockDowngradeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockDowngradeReply(LockDowngradeReply&& from) noexcept
    : LockDowngradeReply() {
    *this = ::std::move(from);
  }

  inline LockDowngradeReply& operator=(LockDowngradeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockDowngradeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockDowngradeReply* internal_default_instance() {
    return reinterpret_cast<const LockDowngradeReply*>(
               &_LockDowngradeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LockDowngradeReply* other);
  friend void swap(LockDowngradeReply& a, LockDowngradeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockDowngradeReply* New() const final {
    return CreateMaybeMessage<LockDowngradeReply>(NULL);
  }

  LockDowngradeReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockDowngradeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockDowngradeReply& from);
  void MergeFrom(const LockDowngradeReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockDowngradeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes page_buf = 2;
  void clear_page_buf();
  static const int kPageBufFieldNumber = 2;
  const ::std::string& page_buf() const;
  void set_page_buf(const ::std::string& value);
  #if LANG_CXX11
  void set_page_buf(::std::string&& value);
  #endif
  void set_page_buf(const char* value);
  void set_page_buf(const void* value, size_t size);
  ::std::string* mutable_page_buf();
  ::std::string* release_page_buf();
  void set_allocated_page_buf(::std::string* page_buf);

  // bool rc = 1;
  void clear_rc();
  static const int kRcFieldNumber = 1;
  bool rc() const;
  void set_rc(bool value);

  // @@protoc_insertion_point(class_scope:dbx1000.LockDowngradeReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr page_buf_;
  bool rc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbx1000_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockInvalidRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockInvalidRequest) */ {
 public:
  LockInvalidRequest();
  virtual ~LockInvalidRequest();

  LockInvalidRequest(const LockInvalidRequest& from);

  inline LockInvalidRequest& operator=(const LockInvalidRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockInvalidRequest(LockInvalidRequest&& from) noexcept
    : LockInvalidRequest() {
    *this = ::std::move(from);
  }

  inline LockInvalidRequest& operator=(LockInvalidRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockInvalidRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockInvalidRequest* internal_default_instance() {
    return reinterpret_cast<const LockInvalidRequest*>(
               &_LockInvalidRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(LockInvalidRequest* other);
  friend void swap(LockInvalidRequest& a, LockInvalidRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockInvalidRequest* New() const final {
    return CreateMaybeMessage<LockInvalidRequest>(NULL);
  }

  LockInvalidRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockInvalidRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockInvalidRequest& from);
  void MergeFrom(const LockInvalidRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockInvalidRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 page_id = 1;
  void clear_page_id();
  static const int kPageIdFieldNumber = 1;
  ::google::protobuf::uint64 page_id() const;
  void set_page_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:dbx1000.LockInvalidRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 page_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbx1000_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockInvalidReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockInvalidReply) */ {
 public:
  LockInvalidReply();
  virtual ~LockInvalidReply();

  LockInvalidReply(const LockInvalidReply& from);

  inline LockInvalidReply& operator=(const LockInvalidReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockInvalidReply(LockInvalidReply&& from) noexcept
    : LockInvalidReply() {
    *this = ::std::move(from);
  }

  inline LockInvalidReply& operator=(LockInvalidReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockInvalidReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockInvalidReply* internal_default_instance() {
    return reinterpret_cast<const LockInvalidReply*>(
               &_LockInvalidReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(LockInvalidReply* other);
  friend void swap(LockInvalidReply& a, LockInvalidReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockInvalidReply* New() const final {
    return CreateMaybeMessage<LockInvalidReply>(NULL);
  }

  LockInvalidReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockInvalidReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockInvalidReply& from);
  void MergeFrom(const LockInvalidReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockInvalidReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool rc = 1;
  void clear_rc();
  static const int kRcFieldNumber = 1;
  bool rc() const;
  void set_rc(bool value);

  // @@protoc_insertion_point(class_scope:dbx1000.LockInvalidReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool rc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbx1000_5fservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LockGetRequest

// int32 instance_id = 1;
inline void LockGetRequest::clear_instance_id() {
  instance_id_ = 0;
}
inline ::google::protobuf::int32 LockGetRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockGetRequest.instance_id)
  return instance_id_;
}
inline void LockGetRequest::set_instance_id(::google::protobuf::int32 value) {
  
  instance_id_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockGetRequest.instance_id)
}

// uint64 page_id = 2;
inline void LockGetRequest::clear_page_id() {
  page_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LockGetRequest::page_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockGetRequest.page_id)
  return page_id_;
}
inline void LockGetRequest::set_page_id(::google::protobuf::uint64 value) {
  
  page_id_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockGetRequest.page_id)
}

// .dbx1000.RpcLockMode mode = 3;
inline void LockGetRequest::clear_mode() {
  mode_ = 0;
}
inline ::dbx1000::RpcLockMode LockGetRequest::mode() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockGetRequest.mode)
  return static_cast< ::dbx1000::RpcLockMode >(mode_);
}
inline void LockGetRequest::set_mode(::dbx1000::RpcLockMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockGetRequest.mode)
}

// -------------------------------------------------------------------

// LockGetReply

// bool rc = 1;
inline void LockGetReply::clear_rc() {
  rc_ = false;
}
inline bool LockGetReply::rc() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockGetReply.rc)
  return rc_;
}
inline void LockGetReply::set_rc(bool value) {
  
  rc_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockGetReply.rc)
}

// bytes page_buf = 2;
inline void LockGetReply::clear_page_buf() {
  page_buf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockGetReply::page_buf() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockGetReply.page_buf)
  return page_buf_.GetNoArena();
}
inline void LockGetReply::set_page_buf(const ::std::string& value) {
  
  page_buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dbx1000.LockGetReply.page_buf)
}
#if LANG_CXX11
inline void LockGetReply::set_page_buf(::std::string&& value) {
  
  page_buf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dbx1000.LockGetReply.page_buf)
}
#endif
inline void LockGetReply::set_page_buf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  page_buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dbx1000.LockGetReply.page_buf)
}
inline void LockGetReply::set_page_buf(const void* value, size_t size) {
  
  page_buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dbx1000.LockGetReply.page_buf)
}
inline ::std::string* LockGetReply::mutable_page_buf() {
  
  // @@protoc_insertion_point(field_mutable:dbx1000.LockGetReply.page_buf)
  return page_buf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockGetReply::release_page_buf() {
  // @@protoc_insertion_point(field_release:dbx1000.LockGetReply.page_buf)
  
  return page_buf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockGetReply::set_allocated_page_buf(::std::string* page_buf) {
  if (page_buf != NULL) {
    
  } else {
    
  }
  page_buf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page_buf);
  // @@protoc_insertion_point(field_set_allocated:dbx1000.LockGetReply.page_buf)
}

// -------------------------------------------------------------------

// LockDowngradeRequest

// uint64 page_id = 1;
inline void LockDowngradeRequest::clear_page_id() {
  page_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LockDowngradeRequest::page_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockDowngradeRequest.page_id)
  return page_id_;
}
inline void LockDowngradeRequest::set_page_id(::google::protobuf::uint64 value) {
  
  page_id_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockDowngradeRequest.page_id)
}

// .dbx1000.RpcLockMode from = 2;
inline void LockDowngradeRequest::clear_from() {
  from_ = 0;
}
inline ::dbx1000::RpcLockMode LockDowngradeRequest::from() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockDowngradeRequest.from)
  return static_cast< ::dbx1000::RpcLockMode >(from_);
}
inline void LockDowngradeRequest::set_from(::dbx1000::RpcLockMode value) {
  
  from_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockDowngradeRequest.from)
}

// .dbx1000.RpcLockMode to = 3;
inline void LockDowngradeRequest::clear_to() {
  to_ = 0;
}
inline ::dbx1000::RpcLockMode LockDowngradeRequest::to() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockDowngradeRequest.to)
  return static_cast< ::dbx1000::RpcLockMode >(to_);
}
inline void LockDowngradeRequest::set_to(::dbx1000::RpcLockMode value) {
  
  to_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockDowngradeRequest.to)
}

// -------------------------------------------------------------------

// LockDowngradeReply

// bool rc = 1;
inline void LockDowngradeReply::clear_rc() {
  rc_ = false;
}
inline bool LockDowngradeReply::rc() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockDowngradeReply.rc)
  return rc_;
}
inline void LockDowngradeReply::set_rc(bool value) {
  
  rc_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockDowngradeReply.rc)
}

// bytes page_buf = 2;
inline void LockDowngradeReply::clear_page_buf() {
  page_buf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockDowngradeReply::page_buf() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockDowngradeReply.page_buf)
  return page_buf_.GetNoArena();
}
inline void LockDowngradeReply::set_page_buf(const ::std::string& value) {
  
  page_buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dbx1000.LockDowngradeReply.page_buf)
}
#if LANG_CXX11
inline void LockDowngradeReply::set_page_buf(::std::string&& value) {
  
  page_buf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dbx1000.LockDowngradeReply.page_buf)
}
#endif
inline void LockDowngradeReply::set_page_buf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  page_buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dbx1000.LockDowngradeReply.page_buf)
}
inline void LockDowngradeReply::set_page_buf(const void* value, size_t size) {
  
  page_buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dbx1000.LockDowngradeReply.page_buf)
}
inline ::std::string* LockDowngradeReply::mutable_page_buf() {
  
  // @@protoc_insertion_point(field_mutable:dbx1000.LockDowngradeReply.page_buf)
  return page_buf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockDowngradeReply::release_page_buf() {
  // @@protoc_insertion_point(field_release:dbx1000.LockDowngradeReply.page_buf)
  
  return page_buf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockDowngradeReply::set_allocated_page_buf(::std::string* page_buf) {
  if (page_buf != NULL) {
    
  } else {
    
  }
  page_buf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), page_buf);
  // @@protoc_insertion_point(field_set_allocated:dbx1000.LockDowngradeReply.page_buf)
}

// -------------------------------------------------------------------

// LockInvalidRequest

// uint64 page_id = 1;
inline void LockInvalidRequest::clear_page_id() {
  page_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LockInvalidRequest::page_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockInvalidRequest.page_id)
  return page_id_;
}
inline void LockInvalidRequest::set_page_id(::google::protobuf::uint64 value) {
  
  page_id_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockInvalidRequest.page_id)
}

// -------------------------------------------------------------------

// LockInvalidReply

// bool rc = 1;
inline void LockInvalidReply::clear_rc() {
  rc_ = false;
}
inline bool LockInvalidReply::rc() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockInvalidReply.rc)
  return rc_;
}
inline void LockInvalidReply::set_rc(bool value) {
  
  rc_ = value;
  // @@protoc_insertion_point(field_set:dbx1000.LockInvalidReply.rc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dbx1000

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::dbx1000::RpcLockMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dbx1000::RpcLockMode>() {
  return ::dbx1000::RpcLockMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_dbx1000_5fservice_2eproto
